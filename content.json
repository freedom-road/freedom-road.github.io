{"posts":[{"title":"Github + Hexo 免费搭建私人博客网站","text":"Hexo简介关于Github就不多说了，这里介绍下Hexo。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 博客搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 将Hexo部署到GitHub 设置个人域名 (可选) 更改主题 icarus 发布文章 安装Hexo所有必备的应用程序（Git、Node.js）安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 输入 hexo -v 查看一下版本，检查是否安装成功。 初始化Hexo12345$ hexo init 文件夹名$ cd 文件夹名$ npm install$ hexo g$ hexo s 博客初始化后会生成多个文件夹，每个文件夹的作用如下： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 至此，博客项目就能在本地运行起来了，是不是非常简单。到这里再介绍下Hexo最常用的几个命令 12345hexo help # 查看帮助hexo init # 初始化博客项目hexo clean # 清理缓存hexo generate # 生成项目hexo deploy # 部署项目 更详细的命令介绍，请查看官网介绍：指令 | Hexo。 发布博客到Github在发布博客之前，我们需要在自己的Github上创建一个仓库用于存放博客内容。假设我们现在有一个叫做freedom-road的Github账号，那么这个仓库的名字需定义为freedom-road.github.io。 然后在Hexo的配置文件中将博客项目和Github关联，具体的配置也非常简单。 12345# _config.ymldeploy: type: git repo: git@github.com:freedom-road/freedom-road.github.io.git branch: master 经过上面的配置后，就可以进行博客发布。 123$ hexo clean$ hexo generate$ hexo deploy # 这步需要执行 npm install hexo-deployer-git --save 安装插件 上面的配置中，Github是使用SSH的形式进行发布的。所以如果你在Github上没配置过公钥的话还需要配置公钥。 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 更换博客主题我自己的博客使用的是icarus，配置起来非常简单。 12$ npm install hexo-theme-icarus$ hexo config theme icarus 另外一种安装方式： 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 参考 Hexo官网 Icarus (ppoffice.github.io) Icarus 配置文件 辣椒の酱 (removeif.github.io) Github + hexo 实现自己的个人博客、配置主题（超详细） - 掘金 (juejin.cn)","link":"/55b848b0ad8d/"},{"title":"Spring 注解系列之 @PropertySource","text":"在 Spring 框架中 @PropertySource 是非常常用的一个注解，其主要作用是将外部化配置解析成键值对“存入“Spring 容器的 Environment 环境里，以便在 Spring 应用中可以通过 @Value 或者占位符 ${key} 的形式来使用这些配置。 使用案列123456789101112131415161718// @PropertySource 需要和 @Configuration 配合使用// @PropertySource 加载配置文件时需要注意加载的顺序，后面加载的配置会覆盖前面加载的配置// @PropertySource 支持重复注解// value 值不仅支持 classpath 表达式，还支持任意合法的 URI 表达式@Configuration@PropertySource(value = &quot;classpath:/my.properties&quot;,encoding = &quot;UTF8&quot;)@PropertySource(value = &quot;classpath:/my2.properties&quot;,encoding = &quot;UTF8&quot;,ignoreResourceNotFound = true)public static class PropertyConfig {}@Componentpublic class App { @Value(&quot;${key1:default-val}&quot;) private String value; @Value(&quot;${key2:default-val2}&quot;) private String value2;} 下面是配置文件 my.properties 和 my2.properties 的具体内容。 123456# my.propertieskey1= 自由之路# my2.propertieskey1= 程序员key2= 自由之路 Spring 容器启动时，会将 my.properties 和 my2.properties 的内容加载到 Environment 中，并在 App 类的依赖注入环节，将 key1 和 key2 的值注入到对应的属性。 自定义 PropertySource 工厂阅读 @PropertySource 的源代码，我们发现还有一个 factory 属性。从这个属性的字面意思看，我们不难猜测出这个属性设置的是用于产生 PropertySource 的工厂。 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource { String name() default &quot;&quot;; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default &quot;&quot;; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;} 要深入理解 PropertySourceFactory，我们先要知道以下的背景知识。 在 Spring 中，配置的来源有很多。Spring 将配置来源统一抽象成 PropertySource 这个抽象类，Spring 中内建的常用的 PropertySource 有以下这些： MapPropertySource CommandLinePropertySource PropertiesPropertySource SystemEnvironmentPropertySource ResourcePropertySource ResourcePropertySource 这个类将一系列配置来源统一成 ResourcePropertySource，可以说是对 PropertySource 的进一步封装。 PropertySourceFactory 接口，用于产生 PropertySource。Spring 中，PropertySourceFactory 默认的实现是 DefaultPropertySourceFactory，用于生产 ResourcePropertySource。 经过上面的介绍，我们知道如果没有配置 @PropertySource 的 factory 属性的话，默认的 PropertySourceFactory 使用的就是 DefaultPropertySourceFactory。当然，我们也可以自定义 PropertySourceFactory，用于“生产”我们自定义的 PropertySource。下面就演示一个将 yaml 文件解析成 MapPropertySource 的使用案列。 12345678910111213141516171819202122/** * Spring 中内置的解析 yaml 的处理器 * YamlProcessor * - YamlMapFactoryBean --&gt; 解析成 Map * - YamlPropertiesFactoryBean --&gt; 解析成 Properties */public class YamlMapSourceFactory implements PropertySourceFactory { @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { YamlMapFactoryBean yamlMapFactoryBean = new YamlMapFactoryBean(); yamlMapFactoryBean.setResources(resource.getResource()); Map&lt;String, Object&gt; map = yamlMapFactoryBean.getObject(); return new MapPropertySource(name, map); }}// 加了 factory 属性，必须加 name 属性// 有了 factory 机制，我们可以做很多自定一的扩展，比如配置可以从远程来@Configuration@PropertySource(name = &quot;my.yaml&quot;,value = &quot;classpath:/my.yaml&quot;,encoding = &quot;UTF8&quot;,factory = YamlMapSourceFactory.class)public static class PropertyConfig {} 原理简析到这边我们对 @PropertySource 已经有了一个感性的认识，知道了其主要作用是将各种类型的外部化配置文件以键值对的形式加载到 Spring 的 Environment 中。这个部分我们从源码的角度来分析下 Spring 是怎么处理 @PropertySource 这个注解的。分析源码可以加深我们对 @PropertySource 的认识（看源码不是目的，是为了加深理解，学习 Spring 的设计思想）。 @PropertySource 注解的处理是在 ConfigurationClassPostProcessor 中进行触发的。最终会调用到 ConfigurationClassParser 的 processPropertySource 方法。 12345678910111213141516171819202122232425262728293031323334353637383940// ConfigurationClassParser#processPropertySourceprivate void processPropertySource(AnnotationAttributes propertySource) throws IOException { String name = propertySource.getString(&quot;name&quot;); if (!StringUtils.hasLength(name)) { name = null; } String encoding = propertySource.getString(&quot;encoding&quot;); if (!StringUtils.hasLength(encoding)) { encoding = null; } String[] locations = propertySource.getStringArray(&quot;value&quot;); Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;); boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;); // 如果有自定义工厂就使用自定义工厂，没有自定义工厂就使用 DefaultPropertySourceFactory PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); // 遍历各个 location 地址 for (String location : locations) { try { // location 地址支持占位符的形式 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); // 获取 Resource Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); } catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) { // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) { if (logger.isInfoEnabled()) { logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage()); } } else { throw ex; } } }} 总的来说，Spring 处理 @PropertySource 的源代码非常简单，这边就不再过多赘述了。","link":"/7276ee78dc1d/"},{"title":"Spring 工具类系列之 RestTemplate 使用详解","text":"在项目中，当我们需要远程调用一个 HTTP 接口时，我们经常会用到 RestTemplate 这个类。这个类是 Spring 框架提供的一个工具类。Spring 官网对它的介绍如下： RestTemplate: The original Spring REST client with a synchronous, template method API. 从上面的介绍中我们可以知道：RestTemplate 是一个同步的 Rest API 客户端。下面我们就来介绍下 RestTemplate 的常用功能。 RestTemplate 简介RestTemplate 提供高度封装的接口，可以让我们非常方便地进行 Rest API 调用。常见的方法如下： 表格：RestTemplate 的方法 上面的方法我们大致可以分为三组： getForObject 到 optionsForAllow 分为一组，这类方法是常规的 Rest API（GET、POST、DELETE 等）方法调用； exchange：接收一个 RequestEntity 参数，可以自己设置 HTTP method，URL，headers 和 body，返回 ResponseEntity； execute：通过 callback 接口，可以对请求和返回做更加全面的自定义控制。 一般情况下，我们使用第一组和第二组方法就够了。 简单使用创建 RestTemplate123456789101112131415@Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); return restTemplate;}@Beanpublic ClientHttpRequestFactory simpleClientHttpRequestFactory() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setReadTimeout(5000); factory.setConnectTimeout(15000); // 设置代理 // factory.setProxy(null); return factory;} 创建 RestTemplate 时需要一个 ClientHttpRequestFactory，通过这个请求工厂，我们可以统一设置请求的超时时间，设置代理以及一些其他细节。通过上面代码配置后，我们直接在代码中注入 RestTemplate 就可以使用了。 有时候我们还需要通过 ClientHttpRequestFactory 配置最大链接数，忽略 SSL 证书等，大家需要的时候可以自己查看代码设置。 普通接口调用12345678910111213Map&lt;String, String&gt; vars = Collections.singletonMap(&quot;hotel&quot;, &quot;42&quot;);// 通过 GET 方式调用，返回一个 String 值，还可以给 URL 变量设置值（也可通过 uriTemplateHandler 这个属性自定义）String result = restTemplate.getForObject( &quot;https://example.com/hotels/{hotel}/rooms/{hotel}&quot;, String.class, vars);String url = &quot;http://127.0.0.1:8080/hello&quot;;JSONObject param = new JSONObject();// restTemplate 会根据 params 的具体类型，调用合适的 HttpMessageConvert 将请求参数写到请求体 body 中，并在请求头中添加合适的 content-type；// 也会根据 responseType 的类型（本列子中是 JSONObject），设置 head 中的 accept 字段，当响应返回的时候再调用合适的 HttpMessageConvert 进行响应转换ResponseEntity&lt;JSONObject&gt; responseEntity=restTemplate.postForEntity(url,params,JSONObject.class);int statusCodeValue = responseEntity.getStatusCodeValue();HttpHeaders headers = responseEntity.getHeaders();JSONObject body = responseEntity.getBody(); 添加 Header 和 Cookie有时候，我们需要在请求中的 Head 中添加值或者将某些值通过 cookie 传给服务端，那么上面这种调用形式就不太满足要求了。 123456789101112131415 UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(&quot;127.0.0.1:8080&quot;). path(&quot;/test&quot;).build(true); URI uri = uriComponents.toUri(); RequestEntity&lt;JSONObject&gt; requestEntity = RequestEntity.post(uri). // 添加 cookie(这边有个问题，假如我们要设置 cookie 的生命周期，作用域等参数我们要怎么操作) header(HttpHeaders.COOKIE,&quot;key1=value1&quot;). // 添加 header header((&quot;MyRequestHeader&quot;, &quot;MyValue&quot;) accept(MediaType.APPLICATION_JSON). contentType(MediaType.APPLICATION_JSON). body(requestParam);ResponseEntity&lt;JSONObject&gt; responseEntity = restTemplate.exchange(requestEntity,JSONObject.class);// 响应结果JSONObject responseEntityBody = responseEntity.getBody(); 文件上传上面两个列子基本能覆盖我们平时开发的大多数功能了。这边再讲个文件上传的列子（RestTemplate 功能还是蛮全的）。 12345678910111213141516171819public Object uplaod(@RequestBody JSONObject params) throws Exception{ final String url = &quot;http://localhost:8888/hello/m3&quot;; // 设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); // 设置请求体，注意是 LinkedMultiValueMap FileSystemResource resource1 = new FileSystemResource(&quot;D:\\\\dir1\\\\ss\\\\pic1.jpg&quot;); FileSystemResource resource2 = new FileSystemResource(&quot;D:\\\\dir1\\\\ss\\\\pic2.jpg&quot;); MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;(); form.add(&quot;file&quot;, resource1); form.add(&quot;file&quot;, resource2); form.add(&quot;param1&quot;,&quot;value1&quot;); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = new HttpEntity&lt;&gt;(form, headers); JSONObject s = restTemplate.postForObject(url, files, JSONObject.class); return s; } 上面的代码中上传了两个本地图片，通过下面代码可以顺利接收。 1234567891011121314151617181920@RequestMapping(&quot;/m3&quot;)public Object fileUpload(@RequestParam(&quot;file&quot;)MultipartFile[] files, HttpServletRequest request) throws Exception { // 携带的其他参数可以使用 getParameter 方法接收 String param1 = request.getParameter(&quot;param1&quot;); Response response = new Response(); if (files == null) { response.failure(&quot;文件上传错误, 服务端未拿到上传的文件！&quot;); return response; } for (MultipartFile file : files) { if (!file.isEmpty() &amp;&amp; file.getSize()&gt; 0) { String fileName = file.getOriginalFilename(); // 参考 FileCopyUtils 这个工具类 file.transferTo(new File(&quot;D:\\\\&quot; + fileName)); logger.info(&quot;文件:{} 上传成功...&quot;,fileName); } } response.success(&quot;文件上传成功&quot;); return response; } 但是我们发现上面的上传代码中，上传文件的类必须使用 FileSystemResource。有时我们会碰到这种情况：文件我们会从文件服务下载到内存中一个 InputStream 的形式存在，那此时在使用 FileSystemResource 就不行了。 当然，我们使用讨巧一点的办法也是可以的：先将下载下来的 InputStream 保存到本地，然后再读取到 FileSystemResource，上传后再删除本地临时文件。 但是总觉得这个方法不够完美。最后发现有个同事已经写了相关的实现。这边就直接拿来用了。 123456789101112131415161718192021// 自己实现了一个 Resourcepublic class InMemoryResource extends ByteArrayResource { private final String filename; private final long lastModified; public InMemoryResource(String filename, String description, byte[] content, long lastModified) { super(content, description); this.lastModified = lastModified; this.filename = filename; } @Override public long lastModified() throws IOException { return this.lastModified; } @Override public String getFilename() { return this.filename; }} 调整后的上传代码 1234567891011121314151617181920212223@PostMapping(&quot;/m3&quot;) public Object m3(@RequestBody JSONObject params) throws Exception{ final String url = &quot;http://localhost:8888/hello/m3&quot;; // 设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); // 设置请求体，注意是 LinkedMultiValueMap // 下面两个流从文件服务下载，这边省略（注意最后关闭流） InputStream fis1 = InputStream fis2 = InMemoryResource resource1 = new InMemoryResource(&quot;file1.jpg&quot;,&quot;description1&quot;, FileCopyUtils.copyToByteArray(fis1), System.currentTimeMillis()); InMemoryResource resource2 = new InMemoryResource(&quot;file2.jpg&quot;,&quot;description2&quot;, FileCopyUtils.copyToByteArray(fis2), System.currentTimeMillis()); MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;(); form.add(&quot;file&quot;, resource1); form.add(&quot;file&quot;, resource2); form.add(&quot;param1&quot;,&quot;value1&quot;); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = new HttpEntity&lt;&gt;(form, headers); JSONObject s = restTemplate.postForObject(url, files, JSONObject.class); return s; } 文件下载1234private InputStream downLoadVideoFromVod(String url) throws Exception { byte[] bytes = restTemplate.getForObject(url, byte[].class); return new ByteArrayInputStream(bytes);} 一些其他设置**1. 拦截器配置 ** RestTemplate 也可以设置拦截器做一些统一处理。这个功能感觉和 Spring MVC 的拦截器类似。配置也很简单： 12345678class MyInterceptor implements ClientHttpRequestInterceptor{ @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { logger.info(&quot;enter interceptor...&quot;); return execution.execute(request,body); } } 123456789 @Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); MyInterceptor myInterceptor = new MyInterceptor(); List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;(); list.add(myInterceptor); restTemplate.setInterceptors(list); return restTemplate;} **2. ErrorHandler 配置 ** ErrorHandler 用来对调用错误对统一处理。 12345678910111213141516171819202122232425262728293031323334353637public class MyResponseErrorHandler extends DefaultResponseErrorHandler { @Override public boolean hasError(ClientHttpResponse response) throws IOException { return super.hasError(response); } @Override public void handleError(ClientHttpResponse response) throws IOException { HttpStatus statusCode = HttpStatus.resolve(response.getRawStatusCode()); if (statusCode == null) { throw new UnknownHttpStatusCodeException(response.getRawStatusCode(), response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); } handleError(response, statusCode); } @Override protected void handleError(ClientHttpResponse response, HttpStatus statusCode) throws IOException { switch (statusCode.series()) { case CLIENT_ERROR: HttpClientErrorException exp1 = new HttpClientErrorException(statusCode, response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;客户端调用异常&quot;,exp1); throw exp1; case SERVER_ERROR: HttpServerErrorException exp2 = new HttpServerErrorException(statusCode, response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;服务端调用异常&quot;,exp2); throw exp2; default: UnknownHttpStatusCodeException exp3 = new UnknownHttpStatusCodeException(statusCode.value(), response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;网络调用未知异常&quot;); throw exp3; } } } 12345678910@Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); MyResponseErrorHandler errorHandler = new MyResponseErrorHandler(); restTemplate.setErrorHandler(errorHandler); List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); // 通过下面代码可以添加新的 HttpMessageConverter // messageConverters.add(new); return restTemplate;} **3. HttpMessageConverter 配置 **RestTemplate 也可以配置 HttpMessageConverter，配置的原理和 Spring MVC 中类似。 简单总结通过 RestTemplate，我们可以非常方便的进行 Rest API 调用。但是在 Spring 5 中已经不再建议使用 RestTemplate，而是更建议使用 WebClient。WebClient 是一个支持异步调用的 Client。所以喜欢研究新东西的同学可以开始研究下新东西了。","link":"/0977d46b10bd/"},{"title":"JDBC 简明教程","text":"虽然在平时的开发过程中我们不会直接使 JDBC 的 API 来操作数据库，但是 JDBC 是大多数 ORM 框架的基础。只有掌握了 JDBC 的使用才能更好的掌握 ORM 框架。本篇博客就对 JDBC 做下介绍，以及使用 JDBC 操作数据库的一般流程。 JDBC（Java 数据库连接）是 Sun 公司提供的一组操作数据库的接口。各个数据库厂商提供具体的数据库驱动实现类。开发者就可以通过统一的 JDBC API 来访问各类数据库了。JDBC 可以帮我们完成下面三件事： 建立数据库连接； 执行各类 SQL 语句； 获得 SQL 语句执行的结果。 常用类 DriverManager：主要使用该类获取数据库连接对象； 1public static Connection getConnection(String url,String user, String password) throws SQLException Connection：代表数据库连接对象，每个对象代表一个数据库物理连接，在操作数据库之前必须先获得该对象；该接口常用的方法如下： 123456// 返回一个 Statement 对象Statement createStatement() throws SQLException;// 返回一个预编译的 Statement 对象，也就是先将 Sql 语句提交到数据库进行预编译PreparedStatement prepareStatement(String sql) throws SQLException;// 该对象用于调用存储过程CallableStatement prepareCall(String sql) throws SQLException; 另外 Connection 对象还提供了如下对象来对事务进行操作： 1234567891011// 设置回滚点Savepoint setSavepoint() throws SQLException;Savepoint setSavepoint(String name) throws SQLException;// 设置隔离级别void setTransactionIsolation(int level) throws SQLException;// 设置回滚点void rollback() throws SQLException;void rollback(Savepoint savepoint) throws SQLException;void setAutoCommit(boolean autoCommit) throws SQLException;// 提交事务void commit(); Statement：用于执行 SQL 语句的工具接口，可以执行 DDL、DML 和查询语句，常用方法如下： 123456// 执行查询 SQL, 并返回结果集ResultSet executeQuery(String sql) throws SQLException;// 执行 DML，并返回影响的条数，也可以执行 DDL，返回 0int executeUpdate(String sql) throws SQLException;// 可以执行所有 SQL，如果 SQL 是查询语句并能查到结果返回 true，否则返回 falseboolean execute(String sql) throws SQLException; PreparedStatement：预编译的 Statement，不需要每次去数据库编译 SQL 语句，只要给 SQL 执行参数就可以了 。 ResultSet：结果集。 JDBC 编程步骤12345678/** * step1: 加载驱动； * step2: 获得连接； * step3: 创建 Statement； * step4: 执行语句，获取结果集； * step5: 处理结果集； * step6: 关闭资源（ResultSet、Statement 和 Connection） */ 事务处理12345// 开启事务setAutoCommit(fasle);// 遇到异常回滚// 提交事务commit(); 数据库连接池每次创建数据库的连接是比较耗费资源的，所以将数据库连接资源缓存起来，重复利用。 DBCP C3P0 Durid JDBC 列子代码下面是一个最简单的 JDBC 列子代码，是一个最典型的 JDBC 查询过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class JDBCUtil { public static final Logger log = LoggerFactory.getLogger(JDBCUtil.class); public static final String URL = &quot;jdbc:mysql://127.0.0.1/mysql&quot;; public static final String DRIVER = &quot;com.mysql.jdbc.Driver&quot;; public static final String USERNAME = &quot;root&quot;; public static final String PASSWORD = &quot;root&quot;; private Connection getConnection(){ Connection conn = null; try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL,USERNAME,PASSWORD); } catch (ClassNotFoundException e) { log.error(&quot;get connection exception&quot;,e); }catch (SQLException e) { log.error(&quot;get connection exception&quot;,e); } return conn; } public void queryAndEchoUser(String userName){ String sql = &quot;select * from user where user = ?&quot;; Connection connection = getConnection(); PreparedStatement preparedStatement; ResultSet resultSet=null; try { preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,&quot;root&quot;); resultSet = preparedStatement.executeQuery(); while (resultSet.next()){ log.info(&quot;host--&gt;&quot;+resultSet.getString(1)); } } catch (SQLException e) { // }finally { // close resultSet // close preparedStatement // close connection } }} 使用 Apache 的 JDBC 工具类上面的代码略微显得复杂，特别是将查出来的结果集转换为 Bean 对象，关闭资源那块。使用 Apache 提供的工具类能适当减少这样的模板代码： 1234567891011121314151617181920212223242526272829public class DbUtilsUseBeanMySQL { public static void main(String[] args) { Connection conn = null; String jdbcURL = &quot;jdbc:mysql://localhost/octopus&quot;; String jdbcDriver = &quot;com.mysql.jdbc.Driver&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; try { DbUtils.loadDriver(jdbcDriver); conn = DriverManager.getConnection(jdbcURL, user, password); QueryRunner qRunner = new QueryRunner(); List beans = (List) qRunner.query(conn, &quot;select id, name from animals_table&quot;, new BeanListHandler(Employee.class)); for (int i = 0; i &lt; beans.size(); i++) { Employee bean = (Employee) beans.get(i); bean.print(); } } catch (SQLException e) { // handle the exception e.printStackTrace(); } finally { DbUtils.closeQuietly(conn); } } } 当然以上只是 DbUtil 最简单的使用，这个工具还支持数据源，事务管理等高级特性，需要的时候可以查询 API 使用。 简单总结总体来说，在实际开发过程中直接使用 JDBC 操作数据库的场景比较少，一般都会使用 ORM 框架进行数据库查询，但是 JDBC 是 ORM 框架的基础，也要熟练掌握。 参考 JDBC 指南 公众号推荐欢迎大家关注我的个人公众号「程序员自由之路」","link":"/cacbeaa351ff/"},{"title":"Spring Boot 可执行 Jar 包运行原理分析","text":"Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。 打可执行 Jar 包将 Spring Boot 应用打成可执行 Ja r 包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行 mvn package 即可。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ** 注意：** 如果你的项目没有继承 spring-boot-starter-parent 这个 POM，你需要做如下配置，将目标绑定到 repackage。 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 关于这个插件的详细使用，可以参考 官网 运行完 mvn package 后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。 可执行 Jar 包内部结构将打出来的可执行 Jar 解压开我们能看到下面的结构： 12345678910111213141516可执行 jar 目录结构├─BOOT-INF│ ├─classes│ └─lib├─META-INF│ ├─maven│ ├─app.properties│ ├─MANIFEST.MF └─org └─springframework └─boot └─loader ├─archive ├─data ├─jar └─util 我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。 12345678910Manifest-Version: 1.0Archiver-Version: Plexus ArchiverBuilt-By: xxxxStart-Class: com.xxxx.AppServerSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Spring-Boot-Version: 2.1.6.RELEASECreated-By: Apache Maven 3.3.9Build-Jdk: 1.8.0_73Main-Class: org.springframework.boot.loader.JarLauncher 在上面我们看到一个熟悉的配置 Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。 再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。 JarLauncher123456789101112131415161718192021222324public class JarLauncher extends ExecutableArchiveLauncher { static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;; static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;; public JarLauncher() { } protected JarLauncher(Archive archive) { super(archive); } @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } public static void main(String[] args) throws Exception { // 项目入口，重点在 launch 这个方法中 new JarLauncher().launch(args); }} 12345678// launch 方法protected void launch(String[] args) throws Exception { JarFile.registerUrlProtocolHandler(); // 创建 LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过 LaunchedURLClassLoader 这个加载器来加载类。这个加载器会从 Boot-INF 下面的 class 目录和 lib 目录下加载类。 ClassLoader classLoader = createClassLoader(getClassPathArchives()); // 这个方法会读取 jar 描述文件中的 Start-Class 属性，然后通过反射调用到这个类的 main 方法。 launch(args, getMainClass(), classLoader);} 简单总结 Spring Boot 程序打包时会将依赖的外部 Jar 到到 BOOT-INF/lib 中，将项目编译出来的 class 文件打包到 BOOT-INF/classes 中； Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法； JarLauncher 的 main 方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载； 读取 Start-Class 属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。 重点就是通过自定义的类加载器加载 Boot-INF 下面的 class 和 lib 目录下的字节码，通过反射机制启动标注有 @SpringApplication 的 main 方法。 远程调试这边再介绍个调试 JarLauncher 启动的小技巧：IDEA 远程调试。 step1：首先以下面的方式启动 Spring Boot 应用 1java -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -jar App.jar step2：在 IDEA 中进行如下配置 然后点击下面的执行按钮执行即可：","link":"/cff62306d258/"},{"title":"Spring Boot 简介","text":"对于做 Java 开发的程序员，Spring 是一个绕不开的框架。现在几乎所有的 Java 项目都会使用 Spring 作为基础框架。但是大概两三年前有一个叫做 Spring Boot 的“家伙”横空出世，其风头好像一时盖过了 Spring。所有基于 Spring 开发的新项目都转向使用 Spring Boot 进行开发了。那么 Spring Boot 究竟是一个什么框架？和 Spring 又有什么关系？本篇博客就来对 Spring Boot 做一个简单介绍。 Spring Boot 简介我们先来看下 Spring Boot 官网对这个框架的介绍： Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”.Our primary goals are:• Provide a radically faster and widely accessible getting-started experience for all Spring development.• Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.• Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).• Absolutely no code generation and no requirement for XML configuration. 上面介绍的大概意思是：使用 Spring Boot 可以非常方便地创建生产级别的 Spring 应用；Spring Boot 提供了很多默认配置，但是程序员也可以非常方便地提供自己的配置；Spring Boot 可以大大减少甚至不使用传统 Spring 项目中的 XML 配置文件。 ** 自己总结下 **：Spring Boot 其实并不是一个新的 Spring 框架，它进行了很多自动配置，目的是让用户能迅速开发基于 Spring 的应用，尽可能减少繁琐的 Spring 配置，提升开发者的开发体验和开发效率。 Spring Boot 进行自动配置的原理是：根据开发者添加的 jar 包依赖（classpath 中的类），自动配置相应的 Bean，从而大大减少开发者手动的配置。比如说开发者添加了 spring-boot-starter-web 这个依赖，那么 Spring Boot 就认为你是要开发 Spring MVC 应用，它会自动帮你配置 DispatcherServlet、HandlerMapping 和 HandlerMethod 等一系列 Spring MVC 的核心组件。开发者就不需要自己在进行配置了。 Spring Boot 另外一个方便的地方是内嵌了 Servlet 容器，我们开发完之后可以直接将应用打成一个可执行的 Jar 包，而不是打成 war 包再部署到自己安装的 Servlet 容器中去。 下面我们用一个 Spring MVC 应用的列子，看看 Spring Boot 到底能给我们带来哪些方便。 使用 Spring Boot 开发项目 ** 传统的开发流程 ** 我们使用传统的 Spring 开发一个 Spring MVC 项目大概要做下面几个步骤： 添加一系列 Spring 的核心依赖，添加 Spring MVC 依赖； 配置 web.xml 配置文件，主要是配置 ContextLoaderListener 和 DispatcherServlet； 进行 Spring MVC 相关的配置，主要是 &lt;mvc:default-servlet-handler/&gt; 和 &lt;mvc:annotation-driven/&gt; 等相关配置； 日志相关配置； 编写相关的 Controller； 打成 war 包，安装 Tomcat，并部署 war 运行。 对于新手来说，上面的流程步骤还是很多的，很有可能在某一步出错。特别是好多刚刚接触 Spring 的同学对于第一步中要添加哪些依赖根本就“傻傻分不清楚”，比较影响学习的积极性。对于老手来说，上面的步骤可能都是一些重复性的操作，比较“浪费时间”。因此需要 Spring Boot 来解决这个问题。 **Spring Boot 开发流程 ** 使用 Spring Boot 开发 Spring MVC 我们需要下面几步： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写主启动类 编写相关的 Controller 直接打成可执行 Jar 包运行。 我们可以发现使用 Spring Boot 真的可以减少很多流程，而且大大减少自己配置出错的概率。 简单总结Spring Boot 是一个能够帮助开发者迅速开发 Spring 应用框架。它大大减少了传统 Spring 应用中的配置文件，提升开发效率和开发体验。同时 Spring Boot 还提了内嵌式的 Servlet 容器，可以将应用打成可执行 Jar 包直接运行。 ** 一些问题 ** 使用 Spring Boot 的确可以提升开发效率。但是它封装了太多细节，对于初学者来说 Spring Boot 也可能是“噩梦”。出了问题不知从何查起。所以我觉得对于框架这种东西我们还是要知道他们的原理性的知识，这样使用起来才能更加得心应手。 如果你是刚刚接触 Spring Boot 下面这些问题可以过段时间再考虑，先将 Spring Boot 用熟练再说。但如果你已经使用 Spring Boot 有段时间了，下面这些问题还是建议自己去琢磨琢磨： Spring Boot 的启动流程是怎样的； Spring Boot 中的自动配置是怎么生效的； 内嵌的 Servlet 容器（比如 Tomcat）是什么时候加载的； 打成的可执行 Jar 包是怎么执行的。 当然上面只是我现在能想到的一些问题，自己在学习过程中可以去不断发现和总结。","link":"/1aaa60e1b2fe/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Java基本功","slug":"Java基本功","link":"/tags/Java%E5%9F%BA%E6%9C%AC%E5%8A%9F/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"技术原理","slug":"技术原理","link":"/tags/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"}],"categories":[],"pages":[]}