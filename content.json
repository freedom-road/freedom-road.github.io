{"posts":[{"title":"Github + Hexo 免费搭建私人博客网站","text":"Hexo简介关于Github就不多说了，这里介绍下Hexo。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 博客搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 将Hexo部署到GitHub 设置个人域名 (可选) 更改主题 icarus 发布文章 安装Hexo所有必备的应用程序（Git、Node.js）安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 输入 hexo -v 查看一下版本，检查是否安装成功。 初始化Hexo12345$ hexo init 文件夹名$ cd 文件夹名$ npm install$ hexo g$ hexo s 博客初始化后会生成多个文件夹，每个文件夹的作用如下： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 至此，博客项目就能在本地运行起来了，是不是非常简单。到这里再介绍下Hexo最常用的几个命令 12345hexo help # 查看帮助hexo init # 初始化博客项目hexo clean # 清理缓存hexo generate # 生成项目hexo deploy # 部署项目 更详细的命令介绍，请查看官网介绍：指令 | Hexo。 发布博客到Github在发布博客之前，我们需要在自己的Github上创建一个仓库用于存放博客内容。假设我们现在有一个叫做freedom-road的Github账号，那么这个仓库的名字需定义为freedom-road.github.io。 然后在Hexo的配置文件中将博客项目和Github关联，具体的配置也非常简单。 12345# _config.ymldeploy: type: git repo: git@github.com:freedom-road/freedom-road.github.io.git branch: master 经过上面的配置后，就可以进行博客发布。 123$ hexo clean$ hexo generate$ hexo deploy # 这步需要执行 npm install hexo-deployer-git --save 安装插件 上面的配置中，Github是使用SSH的形式进行发布的。所以如果你在Github上没配置过公钥的话还需要配置公钥。 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 更换博客主题我自己的博客使用的是icarus，配置起来非常简单。 12$ npm install hexo-theme-icarus$ hexo config theme icarus 另外一种安装方式： 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 参考 Hexo官网 Icarus (ppoffice.github.io) Icarus 配置文件 辣椒の酱 (removeif.github.io) Github + hexo 实现自己的个人博客、配置主题（超详细） - 掘金 (juejin.cn)","link":"/55b848b0ad8d/"},{"title":"Spring 注解系列之 @PropertySource","text":"在 Spring 框架中 @PropertySource 是非常常用的一个注解，其主要作用是将外部化配置解析成键值对“存入“Spring 容器的 Environment 环境里，以便在 Spring 应用中可以通过 @Value 或者占位符 ${key} 的形式来使用这些配置。 使用案列123456789101112131415161718// @PropertySource 需要和 @Configuration 配合使用// @PropertySource 加载配置文件时需要注意加载的顺序，后面加载的配置会覆盖前面加载的配置// @PropertySource 支持重复注解// value 值不仅支持 classpath 表达式，还支持任意合法的 URI 表达式@Configuration@PropertySource(value = &quot;classpath:/my.properties&quot;,encoding = &quot;UTF8&quot;)@PropertySource(value = &quot;classpath:/my2.properties&quot;,encoding = &quot;UTF8&quot;,ignoreResourceNotFound = true)public static class PropertyConfig {}@Componentpublic class App { @Value(&quot;${key1:default-val}&quot;) private String value; @Value(&quot;${key2:default-val2}&quot;) private String value2;} 下面是配置文件 my.properties 和 my2.properties 的具体内容。 123456# my.propertieskey1= 自由之路# my2.propertieskey1= 程序员key2= 自由之路 Spring 容器启动时，会将 my.properties 和 my2.properties 的内容加载到 Environment 中，并在 App 类的依赖注入环节，将 key1 和 key2 的值注入到对应的属性。 自定义 PropertySource 工厂阅读 @PropertySource 的源代码，我们发现还有一个 factory 属性。从这个属性的字面意思看，我们不难猜测出这个属性设置的是用于产生 PropertySource 的工厂。 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource { String name() default &quot;&quot;; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default &quot;&quot;; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;} 要深入理解 PropertySourceFactory，我们先要知道以下的背景知识。 在 Spring 中，配置的来源有很多。Spring 将配置来源统一抽象成 PropertySource 这个抽象类，Spring 中内建的常用的 PropertySource 有以下这些： MapPropertySource CommandLinePropertySource PropertiesPropertySource SystemEnvironmentPropertySource ResourcePropertySource ResourcePropertySource 这个类将一系列配置来源统一成 ResourcePropertySource，可以说是对 PropertySource 的进一步封装。 PropertySourceFactory 接口，用于产生 PropertySource。Spring 中，PropertySourceFactory 默认的实现是 DefaultPropertySourceFactory，用于生产 ResourcePropertySource。 经过上面的介绍，我们知道如果没有配置 @PropertySource 的 factory 属性的话，默认的 PropertySourceFactory 使用的就是 DefaultPropertySourceFactory。当然，我们也可以自定义 PropertySourceFactory，用于“生产”我们自定义的 PropertySource。下面就演示一个将 yaml 文件解析成 MapPropertySource 的使用案列。 12345678910111213141516171819202122/** * Spring 中内置的解析 yaml 的处理器 * YamlProcessor * - YamlMapFactoryBean --&gt; 解析成 Map * - YamlPropertiesFactoryBean --&gt; 解析成 Properties */public class YamlMapSourceFactory implements PropertySourceFactory { @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { YamlMapFactoryBean yamlMapFactoryBean = new YamlMapFactoryBean(); yamlMapFactoryBean.setResources(resource.getResource()); Map&lt;String, Object&gt; map = yamlMapFactoryBean.getObject(); return new MapPropertySource(name, map); }}// 加了 factory 属性，必须加 name 属性// 有了 factory 机制，我们可以做很多自定一的扩展，比如配置可以从远程来@Configuration@PropertySource(name = &quot;my.yaml&quot;,value = &quot;classpath:/my.yaml&quot;,encoding = &quot;UTF8&quot;,factory = YamlMapSourceFactory.class)public static class PropertyConfig {} 原理简析到这边我们对 @PropertySource 已经有了一个感性的认识，知道了其主要作用是将各种类型的外部化配置文件以键值对的形式加载到 Spring 的 Environment 中。这个部分我们从源码的角度来分析下 Spring 是怎么处理 @PropertySource 这个注解的。分析源码可以加深我们对 @PropertySource 的认识（看源码不是目的，是为了加深理解，学习 Spring 的设计思想）。 @PropertySource 注解的处理是在 ConfigurationClassPostProcessor 中进行触发的。最终会调用到 ConfigurationClassParser 的 processPropertySource 方法。 12345678910111213141516171819202122232425262728293031323334353637383940// ConfigurationClassParser#processPropertySourceprivate void processPropertySource(AnnotationAttributes propertySource) throws IOException { String name = propertySource.getString(&quot;name&quot;); if (!StringUtils.hasLength(name)) { name = null; } String encoding = propertySource.getString(&quot;encoding&quot;); if (!StringUtils.hasLength(encoding)) { encoding = null; } String[] locations = propertySource.getStringArray(&quot;value&quot;); Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;); boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;); // 如果有自定义工厂就使用自定义工厂，没有自定义工厂就使用 DefaultPropertySourceFactory PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); // 遍历各个 location 地址 for (String location : locations) { try { // location 地址支持占位符的形式 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); // 获取 Resource Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); } catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) { // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) { if (logger.isInfoEnabled()) { logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage()); } } else { throw ex; } } }} 总的来说，Spring 处理 @PropertySource 的源代码非常简单，这边就不再过多赘述了。","link":"/7276ee78dc1d/"},{"title":"Spring Boot 简介","text":"对于做 Java 开发的程序员，Spring 是一个绕不开的框架。现在几乎所有的 Java 项目都会使用 Spring 作为基础框架。但是大概两三年前有一个叫做 Spring Boot 的“家伙”横空出世，其风头好像一时盖过了 Spring。所有基于 Spring 开发的新项目都转向使用 Spring Boot 进行开发了。那么 Spring Boot 究竟是一个什么框架？和 Spring 又有什么关系？本篇博客就来对 Spring Boot 做一个简单介绍。 Spring Boot 简介我们先来看下 Spring Boot 官网对这个框架的介绍： Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”.Our primary goals are:• Provide a radically faster and widely accessible getting-started experience for all Spring development.• Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.• Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).• Absolutely no code generation and no requirement for XML configuration. 上面介绍的大概意思是：使用 Spring Boot 可以非常方便地创建生产级别的 Spring 应用；Spring Boot 提供了很多默认配置，但是程序员也可以非常方便地提供自己的配置；Spring Boot 可以大大减少甚至不使用传统 Spring 项目中的 XML 配置文件。 ** 自己总结下 **：Spring Boot 其实并不是一个新的 Spring 框架，它进行了很多自动配置，目的是让用户能迅速开发基于 Spring 的应用，尽可能减少繁琐的 Spring 配置，提升开发者的开发体验和开发效率。 Spring Boot 进行自动配置的原理是：根据开发者添加的 jar 包依赖（classpath 中的类），自动配置相应的 Bean，从而大大减少开发者手动的配置。比如说开发者添加了 spring-boot-starter-web 这个依赖，那么 Spring Boot 就认为你是要开发 Spring MVC 应用，它会自动帮你配置 DispatcherServlet、HandlerMapping 和 HandlerMethod 等一系列 Spring MVC 的核心组件。开发者就不需要自己在进行配置了。 Spring Boot 另外一个方便的地方是内嵌了 Servlet 容器，我们开发完之后可以直接将应用打成一个可执行的 Jar 包，而不是打成 war 包再部署到自己安装的 Servlet 容器中去。 下面我们用一个 Spring MVC 应用的列子，看看 Spring Boot 到底能给我们带来哪些方便。 使用 Spring Boot 开发项目 ** 传统的开发流程 ** 我们使用传统的 Spring 开发一个 Spring MVC 项目大概要做下面几个步骤： 添加一系列 Spring 的核心依赖，添加 Spring MVC 依赖； 配置 web.xml 配置文件，主要是配置 ContextLoaderListener 和 DispatcherServlet； 进行 Spring MVC 相关的配置，主要是 &lt;mvc:default-servlet-handler/&gt; 和 &lt;mvc:annotation-driven/&gt; 等相关配置； 日志相关配置； 编写相关的 Controller； 打成 war 包，安装 Tomcat，并部署 war 运行。 对于新手来说，上面的流程步骤还是很多的，很有可能在某一步出错。特别是好多刚刚接触 Spring 的同学对于第一步中要添加哪些依赖根本就“傻傻分不清楚”，比较影响学习的积极性。对于老手来说，上面的步骤可能都是一些重复性的操作，比较“浪费时间”。因此需要 Spring Boot 来解决这个问题。 **Spring Boot 开发流程 ** 使用 Spring Boot 开发 Spring MVC 我们需要下面几步： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写主启动类 编写相关的 Controller 直接打成可执行 Jar 包运行。 我们可以发现使用 Spring Boot 真的可以减少很多流程，而且大大减少自己配置出错的概率。 简单总结Spring Boot 是一个能够帮助开发者迅速开发 Spring 应用框架。它大大减少了传统 Spring 应用中的配置文件，提升开发效率和开发体验。同时 Spring Boot 还提了内嵌式的 Servlet 容器，可以将应用打成可执行 Jar 包直接运行。 ** 一些问题 ** 使用 Spring Boot 的确可以提升开发效率。但是它封装了太多细节，对于初学者来说 Spring Boot 也可能是“噩梦”。出了问题不知从何查起。所以我觉得对于框架这种东西我们还是要知道他们的原理性的知识，这样使用起来才能更加得心应手。 如果你是刚刚接触 Spring Boot 下面这些问题可以过段时间再考虑，先将 Spring Boot 用熟练再说。但如果你已经使用 Spring Boot 有段时间了，下面这些问题还是建议自己去琢磨琢磨： Spring Boot 的启动流程是怎样的； Spring Boot 中的自动配置是怎么生效的； 内嵌的 Servlet 容器（比如 Tomcat）是什么时候加载的； 打成的可执行 Jar 包是怎么执行的。 当然上面只是我现在能想到的一些问题，自己在学习过程中可以去不断发现和总结。","link":"/d2442c442f21/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"}],"categories":[],"pages":[]}