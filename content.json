{"posts":[{"title":"Github + Hexo 免费搭建私人博客网站","text":"Hexo简介关于Github就不多说了，这里介绍下Hexo。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 博客搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 将Hexo部署到GitHub 设置个人域名 (可选) 更改主题 icarus 发布文章 安装Hexo所有必备的应用程序（Git、Node.js）安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 输入 hexo -v 查看一下版本，检查是否安装成功。 初始化Hexo12345$ hexo init 文件夹名$ cd 文件夹名$ npm install$ hexo g$ hexo s 博客初始化后会生成多个文件夹，每个文件夹的作用如下： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 至此，博客项目就能在本地运行起来了，是不是非常简单。到这里再介绍下Hexo最常用的几个命令 12345hexo help # 查看帮助hexo init # 初始化博客项目hexo clean # 清理缓存hexo generate # 生成项目hexo deploy # 部署项目 更详细的命令介绍，请查看官网介绍：指令 | Hexo。 发布博客到Github在发布博客之前，我们需要在自己的Github上创建一个仓库用于存放博客内容。假设我们现在有一个叫做freedom-road的Github账号，那么这个仓库的名字需定义为freedom-road.github.io。 然后在Hexo的配置文件中将博客项目和Github关联，具体的配置也非常简单。 12345# _config.ymldeploy: type: git repo: git@github.com:freedom-road/freedom-road.github.io.git branch: master 经过上面的配置后，就可以进行博客发布。 123$ hexo clean$ hexo generate$ hexo deploy # 这步需要执行 npm install hexo-deployer-git --save 安装插件 上面的配置中，Github是使用SSH的形式进行发布的。所以如果你在Github上没配置过公钥的话还需要配置公钥。 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 更换博客主题我自己的博客使用的是icarus，配置起来非常简单。 12$ npm install hexo-theme-icarus$ hexo config theme icarus 另外一种安装方式： 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 参考 Hexo官网 Icarus (ppoffice.github.io) Icarus 配置文件 辣椒の酱 (removeif.github.io) Github + hexo 实现自己的个人博客、配置主题（超详细） - 掘金 (juejin.cn)","link":"/55b848b0ad8d/"},{"title":"Spring 注解系列之 @PropertySource","text":"在 Spring 框架中 @PropertySource 是非常常用的一个注解，其主要作用是将外部化配置解析成键值对“存入“Spring 容器的 Environment 环境里，以便在 Spring 应用中可以通过 @Value 或者占位符 ${key} 的形式来使用这些配置。 使用案列123456789101112131415161718// @PropertySource 需要和 @Configuration 配合使用// @PropertySource 加载配置文件时需要注意加载的顺序，后面加载的配置会覆盖前面加载的配置// @PropertySource 支持重复注解// value 值不仅支持 classpath 表达式，还支持任意合法的 URI 表达式@Configuration@PropertySource(value = &quot;classpath:/my.properties&quot;,encoding = &quot;UTF8&quot;)@PropertySource(value = &quot;classpath:/my2.properties&quot;,encoding = &quot;UTF8&quot;,ignoreResourceNotFound = true)public static class PropertyConfig {}@Componentpublic class App { @Value(&quot;${key1:default-val}&quot;) private String value; @Value(&quot;${key2:default-val2}&quot;) private String value2;} 下面是配置文件 my.properties 和 my2.properties 的具体内容。 123456# my.propertieskey1= 自由之路# my2.propertieskey1= 程序员key2= 自由之路 Spring 容器启动时，会将 my.properties 和 my2.properties 的内容加载到 Environment 中，并在 App 类的依赖注入环节，将 key1 和 key2 的值注入到对应的属性。 自定义 PropertySource 工厂阅读 @PropertySource 的源代码，我们发现还有一个 factory 属性。从这个属性的字面意思看，我们不难猜测出这个属性设置的是用于产生 PropertySource 的工厂。 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource { String name() default &quot;&quot;; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default &quot;&quot;; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;} 要深入理解 PropertySourceFactory，我们先要知道以下的背景知识。 在 Spring 中，配置的来源有很多。Spring 将配置来源统一抽象成 PropertySource 这个抽象类，Spring 中内建的常用的 PropertySource 有以下这些： MapPropertySource CommandLinePropertySource PropertiesPropertySource SystemEnvironmentPropertySource ResourcePropertySource ResourcePropertySource 这个类将一系列配置来源统一成 ResourcePropertySource，可以说是对 PropertySource 的进一步封装。 PropertySourceFactory 接口，用于产生 PropertySource。Spring 中，PropertySourceFactory 默认的实现是 DefaultPropertySourceFactory，用于生产 ResourcePropertySource。 经过上面的介绍，我们知道如果没有配置 @PropertySource 的 factory 属性的话，默认的 PropertySourceFactory 使用的就是 DefaultPropertySourceFactory。当然，我们也可以自定义 PropertySourceFactory，用于“生产”我们自定义的 PropertySource。下面就演示一个将 yaml 文件解析成 MapPropertySource 的使用案列。 12345678910111213141516171819202122/** * Spring 中内置的解析 yaml 的处理器 * YamlProcessor * - YamlMapFactoryBean --&gt; 解析成 Map * - YamlPropertiesFactoryBean --&gt; 解析成 Properties */public class YamlMapSourceFactory implements PropertySourceFactory { @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { YamlMapFactoryBean yamlMapFactoryBean = new YamlMapFactoryBean(); yamlMapFactoryBean.setResources(resource.getResource()); Map&lt;String, Object&gt; map = yamlMapFactoryBean.getObject(); return new MapPropertySource(name, map); }}// 加了 factory 属性，必须加 name 属性// 有了 factory 机制，我们可以做很多自定一的扩展，比如配置可以从远程来@Configuration@PropertySource(name = &quot;my.yaml&quot;,value = &quot;classpath:/my.yaml&quot;,encoding = &quot;UTF8&quot;,factory = YamlMapSourceFactory.class)public static class PropertyConfig {} 原理简析到这边我们对 @PropertySource 已经有了一个感性的认识，知道了其主要作用是将各种类型的外部化配置文件以键值对的形式加载到 Spring 的 Environment 中。这个部分我们从源码的角度来分析下 Spring 是怎么处理 @PropertySource 这个注解的。分析源码可以加深我们对 @PropertySource 的认识（看源码不是目的，是为了加深理解，学习 Spring 的设计思想）。 @PropertySource 注解的处理是在 ConfigurationClassPostProcessor 中进行触发的。最终会调用到 ConfigurationClassParser 的 processPropertySource 方法。 12345678910111213141516171819202122232425262728293031323334353637383940// ConfigurationClassParser#processPropertySourceprivate void processPropertySource(AnnotationAttributes propertySource) throws IOException { String name = propertySource.getString(&quot;name&quot;); if (!StringUtils.hasLength(name)) { name = null; } String encoding = propertySource.getString(&quot;encoding&quot;); if (!StringUtils.hasLength(encoding)) { encoding = null; } String[] locations = propertySource.getStringArray(&quot;value&quot;); Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;); boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;); // 如果有自定义工厂就使用自定义工厂，没有自定义工厂就使用 DefaultPropertySourceFactory PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); // 遍历各个 location 地址 for (String location : locations) { try { // location 地址支持占位符的形式 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); // 获取 Resource Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); } catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) { // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) { if (logger.isInfoEnabled()) { logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage()); } } else { throw ex; } } }} 总的来说，Spring 处理 @PropertySource 的源代码非常简单，这边就不再过多赘述了。","link":"/7276ee78dc1d/"},{"title":"Spring Boot 简介","text":"对于做 Java 开发的程序员，Spring 是一个绕不开的框架。现在几乎所有的 Java 项目都会使用 Spring 作为基础框架。但是大概两三年前有一个叫做 Spring Boot 的“家伙”横空出世，其风头好像一时盖过了 Spring。所有基于 Spring 开发的新项目都转向使用 Spring Boot 进行开发了。那么 Spring Boot 究竟是一个什么框架？和 Spring 又有什么关系？本篇博客就来对 Spring Boot 做一个简单介绍。 Spring Boot 简介我们先来看下 Spring Boot 官网对这个框架的介绍： Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”.Our primary goals are:• Provide a radically faster and widely accessible getting-started experience for all Spring development.• Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.• Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).• Absolutely no code generation and no requirement for XML configuration. 上面介绍的大概意思是：使用 Spring Boot 可以非常方便地创建生产级别的 Spring 应用；Spring Boot 提供了很多默认配置，但是程序员也可以非常方便地提供自己的配置；Spring Boot 可以大大减少甚至不使用传统 Spring 项目中的 XML 配置文件。 ** 自己总结下 **：Spring Boot 其实并不是一个新的 Spring 框架，它进行了很多自动配置，目的是让用户能迅速开发基于 Spring 的应用，尽可能减少繁琐的 Spring 配置，提升开发者的开发体验和开发效率。 Spring Boot 进行自动配置的原理是：根据开发者添加的 jar 包依赖（classpath 中的类），自动配置相应的 Bean，从而大大减少开发者手动的配置。比如说开发者添加了 spring-boot-starter-web 这个依赖，那么 Spring Boot 就认为你是要开发 Spring MVC 应用，它会自动帮你配置 DispatcherServlet、HandlerMapping 和 HandlerMethod 等一系列 Spring MVC 的核心组件。开发者就不需要自己在进行配置了。 Spring Boot 另外一个方便的地方是内嵌了 Servlet 容器，我们开发完之后可以直接将应用打成一个可执行的 Jar 包，而不是打成 war 包再部署到自己安装的 Servlet 容器中去。 下面我们用一个 Spring MVC 应用的列子，看看 Spring Boot 到底能给我们带来哪些方便。 使用 Spring Boot 开发项目 ** 传统的开发流程 ** 我们使用传统的 Spring 开发一个 Spring MVC 项目大概要做下面几个步骤： 添加一系列 Spring 的核心依赖，添加 Spring MVC 依赖； 配置 web.xml 配置文件，主要是配置 ContextLoaderListener 和 DispatcherServlet； 进行 Spring MVC 相关的配置，主要是 &lt;mvc:default-servlet-handler/&gt; 和 &lt;mvc:annotation-driven/&gt; 等相关配置； 日志相关配置； 编写相关的 Controller； 打成 war 包，安装 Tomcat，并部署 war 运行。 对于新手来说，上面的流程步骤还是很多的，很有可能在某一步出错。特别是好多刚刚接触 Spring 的同学对于第一步中要添加哪些依赖根本就“傻傻分不清楚”，比较影响学习的积极性。对于老手来说，上面的步骤可能都是一些重复性的操作，比较“浪费时间”。因此需要 Spring Boot 来解决这个问题。 **Spring Boot 开发流程 ** 使用 Spring Boot 开发 Spring MVC 我们需要下面几步： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写主启动类 编写相关的 Controller 直接打成可执行 Jar 包运行。 我们可以发现使用 Spring Boot 真的可以减少很多流程，而且大大减少自己配置出错的概率。 简单总结Spring Boot 是一个能够帮助开发者迅速开发 Spring 应用框架。它大大减少了传统 Spring 应用中的配置文件，提升开发效率和开发体验。同时 Spring Boot 还提了内嵌式的 Servlet 容器，可以将应用打成可执行 Jar 包直接运行。 ** 一些问题 ** 使用 Spring Boot 的确可以提升开发效率。但是它封装了太多细节，对于初学者来说 Spring Boot 也可能是“噩梦”。出了问题不知从何查起。所以我觉得对于框架这种东西我们还是要知道他们的原理性的知识，这样使用起来才能更加得心应手。 如果你是刚刚接触 Spring Boot 下面这些问题可以过段时间再考虑，先将 Spring Boot 用熟练再说。但如果你已经使用 Spring Boot 有段时间了，下面这些问题还是建议自己去琢磨琢磨： Spring Boot 的启动流程是怎样的； Spring Boot 中的自动配置是怎么生效的； 内嵌的 Servlet 容器（比如 Tomcat）是什么时候加载的； 打成的可执行 Jar 包是怎么执行的。 当然上面只是我现在能想到的一些问题，自己在学习过程中可以去不断发现和总结。","link":"/d2442c442f21/"},{"title":"Spring 工具类系列之 RestTemplate 使用详解","text":"在项目中，当我们需要远程调用一个 HTTP 接口时，我们经常会用到 RestTemplate 这个类。这个类是 Spring 框架提供的一个工具类。Spring 官网对它的介绍如下： RestTemplate: The original Spring REST client with a synchronous, template method API. 从上面的介绍中我们可以知道：RestTemplate 是一个同步的 Rest API 客户端。下面我们就来介绍下 RestTemplate 的常用功能。 RestTemplate 简介RestTemplate 提供高度封装的接口，可以让我们非常方便地进行 Rest API 调用。常见的方法如下： 表格：RestTemplate 的方法 上面的方法我们大致可以分为三组： getForObject 到 optionsForAllow 分为一组，这类方法是常规的 Rest API（GET、POST、DELETE 等）方法调用； exchange：接收一个 RequestEntity 参数，可以自己设置 HTTP method，URL，headers 和 body，返回 ResponseEntity； execute：通过 callback 接口，可以对请求和返回做更加全面的自定义控制。 一般情况下，我们使用第一组和第二组方法就够了。 简单使用创建 RestTemplate123456789101112131415@Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); return restTemplate;}@Beanpublic ClientHttpRequestFactory simpleClientHttpRequestFactory() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setReadTimeout(5000); factory.setConnectTimeout(15000); // 设置代理 // factory.setProxy(null); return factory;} 创建 RestTemplate 时需要一个 ClientHttpRequestFactory，通过这个请求工厂，我们可以统一设置请求的超时时间，设置代理以及一些其他细节。通过上面代码配置后，我们直接在代码中注入 RestTemplate 就可以使用了。 有时候我们还需要通过 ClientHttpRequestFactory 配置最大链接数，忽略 SSL 证书等，大家需要的时候可以自己查看代码设置。 普通接口调用12345678910111213Map&lt;String, String&gt; vars = Collections.singletonMap(&quot;hotel&quot;, &quot;42&quot;);// 通过 GET 方式调用，返回一个 String 值，还可以给 URL 变量设置值（也可通过 uriTemplateHandler 这个属性自定义）String result = restTemplate.getForObject( &quot;https://example.com/hotels/{hotel}/rooms/{hotel}&quot;, String.class, vars);String url = &quot;http://127.0.0.1:8080/hello&quot;;JSONObject param = new JSONObject();// restTemplate 会根据 params 的具体类型，调用合适的 HttpMessageConvert 将请求参数写到请求体 body 中，并在请求头中添加合适的 content-type；// 也会根据 responseType 的类型（本列子中是 JSONObject），设置 head 中的 accept 字段，当响应返回的时候再调用合适的 HttpMessageConvert 进行响应转换ResponseEntity&lt;JSONObject&gt; responseEntity=restTemplate.postForEntity(url,params,JSONObject.class);int statusCodeValue = responseEntity.getStatusCodeValue();HttpHeaders headers = responseEntity.getHeaders();JSONObject body = responseEntity.getBody(); 添加 Header 和 Cookie有时候，我们需要在请求中的 Head 中添加值或者将某些值通过 cookie 传给服务端，那么上面这种调用形式就不太满足要求了。 123456789101112131415 UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(&quot;127.0.0.1:8080&quot;). path(&quot;/test&quot;).build(true); URI uri = uriComponents.toUri(); RequestEntity&lt;JSONObject&gt; requestEntity = RequestEntity.post(uri). // 添加 cookie(这边有个问题，假如我们要设置 cookie 的生命周期，作用域等参数我们要怎么操作) header(HttpHeaders.COOKIE,&quot;key1=value1&quot;). // 添加 header header((&quot;MyRequestHeader&quot;, &quot;MyValue&quot;) accept(MediaType.APPLICATION_JSON). contentType(MediaType.APPLICATION_JSON). body(requestParam);ResponseEntity&lt;JSONObject&gt; responseEntity = restTemplate.exchange(requestEntity,JSONObject.class);// 响应结果JSONObject responseEntityBody = responseEntity.getBody(); 文件上传上面两个列子基本能覆盖我们平时开发的大多数功能了。这边再讲个文件上传的列子（RestTemplate 功能还是蛮全的）。 12345678910111213141516171819public Object uplaod(@RequestBody JSONObject params) throws Exception{ final String url = &quot;http://localhost:8888/hello/m3&quot;; // 设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); // 设置请求体，注意是 LinkedMultiValueMap FileSystemResource resource1 = new FileSystemResource(&quot;D:\\\\dir1\\\\ss\\\\pic1.jpg&quot;); FileSystemResource resource2 = new FileSystemResource(&quot;D:\\\\dir1\\\\ss\\\\pic2.jpg&quot;); MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;(); form.add(&quot;file&quot;, resource1); form.add(&quot;file&quot;, resource2); form.add(&quot;param1&quot;,&quot;value1&quot;); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = new HttpEntity&lt;&gt;(form, headers); JSONObject s = restTemplate.postForObject(url, files, JSONObject.class); return s; } 上面的代码中上传了两个本地图片，通过下面代码可以顺利接收。 1234567891011121314151617181920@RequestMapping(&quot;/m3&quot;)public Object fileUpload(@RequestParam(&quot;file&quot;)MultipartFile[] files, HttpServletRequest request) throws Exception { // 携带的其他参数可以使用 getParameter 方法接收 String param1 = request.getParameter(&quot;param1&quot;); Response response = new Response(); if (files == null) { response.failure(&quot;文件上传错误, 服务端未拿到上传的文件！&quot;); return response; } for (MultipartFile file : files) { if (!file.isEmpty() &amp;&amp; file.getSize()&gt; 0) { String fileName = file.getOriginalFilename(); // 参考 FileCopyUtils 这个工具类 file.transferTo(new File(&quot;D:\\\\&quot; + fileName)); logger.info(&quot;文件:{} 上传成功...&quot;,fileName); } } response.success(&quot;文件上传成功&quot;); return response; } 但是我们发现上面的上传代码中，上传文件的类必须使用 FileSystemResource。有时我们会碰到这种情况：文件我们会从文件服务下载到内存中一个 InputStream 的形式存在，那此时在使用 FileSystemResource 就不行了。 当然，我们使用讨巧一点的办法也是可以的：先将下载下来的 InputStream 保存到本地，然后再读取到 FileSystemResource，上传后再删除本地临时文件。 但是总觉得这个方法不够完美。最后发现有个同事已经写了相关的实现。这边就直接拿来用了。 123456789101112131415161718192021// 自己实现了一个 Resourcepublic class InMemoryResource extends ByteArrayResource { private final String filename; private final long lastModified; public InMemoryResource(String filename, String description, byte[] content, long lastModified) { super(content, description); this.lastModified = lastModified; this.filename = filename; } @Override public long lastModified() throws IOException { return this.lastModified; } @Override public String getFilename() { return this.filename; }} 调整后的上传代码 1234567891011121314151617181920212223@PostMapping(&quot;/m3&quot;) public Object m3(@RequestBody JSONObject params) throws Exception{ final String url = &quot;http://localhost:8888/hello/m3&quot;; // 设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); // 设置请求体，注意是 LinkedMultiValueMap // 下面两个流从文件服务下载，这边省略（注意最后关闭流） InputStream fis1 = InputStream fis2 = InMemoryResource resource1 = new InMemoryResource(&quot;file1.jpg&quot;,&quot;description1&quot;, FileCopyUtils.copyToByteArray(fis1), System.currentTimeMillis()); InMemoryResource resource2 = new InMemoryResource(&quot;file2.jpg&quot;,&quot;description2&quot;, FileCopyUtils.copyToByteArray(fis2), System.currentTimeMillis()); MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;(); form.add(&quot;file&quot;, resource1); form.add(&quot;file&quot;, resource2); form.add(&quot;param1&quot;,&quot;value1&quot;); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = new HttpEntity&lt;&gt;(form, headers); JSONObject s = restTemplate.postForObject(url, files, JSONObject.class); return s; } 文件下载1234private InputStream downLoadVideoFromVod(String url) throws Exception { byte[] bytes = restTemplate.getForObject(url, byte[].class); return new ByteArrayInputStream(bytes);} 一些其他设置**1. 拦截器配置 ** RestTemplate 也可以设置拦截器做一些统一处理。这个功能感觉和 Spring MVC 的拦截器类似。配置也很简单： 12345678class MyInterceptor implements ClientHttpRequestInterceptor{ @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { logger.info(&quot;enter interceptor...&quot;); return execution.execute(request,body); } } 123456789 @Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); MyInterceptor myInterceptor = new MyInterceptor(); List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;(); list.add(myInterceptor); restTemplate.setInterceptors(list); return restTemplate;} **2. ErrorHandler 配置 ** ErrorHandler 用来对调用错误对统一处理。 12345678910111213141516171819202122232425262728293031323334353637public class MyResponseErrorHandler extends DefaultResponseErrorHandler { @Override public boolean hasError(ClientHttpResponse response) throws IOException { return super.hasError(response); } @Override public void handleError(ClientHttpResponse response) throws IOException { HttpStatus statusCode = HttpStatus.resolve(response.getRawStatusCode()); if (statusCode == null) { throw new UnknownHttpStatusCodeException(response.getRawStatusCode(), response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); } handleError(response, statusCode); } @Override protected void handleError(ClientHttpResponse response, HttpStatus statusCode) throws IOException { switch (statusCode.series()) { case CLIENT_ERROR: HttpClientErrorException exp1 = new HttpClientErrorException(statusCode, response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;客户端调用异常&quot;,exp1); throw exp1; case SERVER_ERROR: HttpServerErrorException exp2 = new HttpServerErrorException(statusCode, response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;服务端调用异常&quot;,exp2); throw exp2; default: UnknownHttpStatusCodeException exp3 = new UnknownHttpStatusCodeException(statusCode.value(), response.getStatusText(), response.getHeaders(), getResponseBody(response), getCharset(response)); logger.error(&quot;网络调用未知异常&quot;); throw exp3; } } } 12345678910@Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) { RestTemplate restTemplate = new RestTemplate(factory); MyResponseErrorHandler errorHandler = new MyResponseErrorHandler(); restTemplate.setErrorHandler(errorHandler); List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); // 通过下面代码可以添加新的 HttpMessageConverter // messageConverters.add(new); return restTemplate;} **3. HttpMessageConverter 配置 **RestTemplate 也可以配置 HttpMessageConverter，配置的原理和 Spring MVC 中类似。 简单总结通过 RestTemplate，我们可以非常方便的进行 Rest API 调用。但是在 Spring 5 中已经不再建议使用 RestTemplate，而是更建议使用 WebClient。WebClient 是一个支持异步调用的 Client。所以喜欢研究新东西的同学可以开始研究下新东西了。","link":"/0977d46b10bd/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[],"pages":[]}