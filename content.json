{"posts":[{"title":"Github + Hexo 免费搭建私人博客网站","text":"Hexo简介关于Github就不多说了，这里介绍下Hexo。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 博客搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 将Hexo部署到GitHub 设置个人域名 (可选) 更改主题 icarus 发布文章 安装Hexo所有必备的应用程序（Git、Node.js）安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 输入 hexo -v 查看一下版本，检查是否安装成功。 初始化Hexo12345$ hexo init 文件夹名$ cd 文件夹名$ npm install$ hexo g$ hexo s 博客初始化后会生成多个文件夹，每个文件夹的作用如下： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 至此，博客项目就能在本地运行起来了，是不是非常简单。到这里再介绍下Hexo最常用的几个命令 12345hexo help # 查看帮助hexo init # 初始化博客项目hexo clean # 清理缓存hexo generate # 生成项目hexo deploy # 部署项目 更详细的命令介绍，请查看官网介绍：指令 | Hexo。 发布博客到Github在发布博客之前，我们需要在自己的Github上创建一个仓库用于存放博客内容。假设我们现在有一个叫做freedom-road的Github账号，那么这个仓库的名字需定义为freedom-road.github.io。 然后在Hexo的配置文件中将博客项目和Github关联，具体的配置也非常简单。 12345# _config.ymldeploy: type: git repo: git@github.com:freedom-road/freedom-road.github.io.git branch: master 经过上面的配置后，就可以进行博客发布。 123$ hexo clean$ hexo generate$ hexo deploy # 这步需要执行 npm install hexo-deployer-git --save 安装插件 上面的配置中，Github是使用SSH的形式进行发布的。所以如果你在Github上没配置过公钥的话还需要配置公钥。 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 更换博客主题我自己的博客使用的是icarus，配置起来非常简单。 12$ npm install hexo-theme-icarus$ hexo config theme icarus 另外一种安装方式： 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 参考 Hexo官网 Icarus (ppoffice.github.io) Icarus 配置文件 辣椒の酱 (removeif.github.io) Github + hexo 实现自己的个人博客、配置主题（超详细） - 掘金 (juejin.cn)","link":"/55b848b0ad8d/"},{"title":"Spring 注解系列之 @PropertySource","text":"在 Spring 框架中 @PropertySource 是非常常用的一个注解，其主要作用是将外部化配置解析成键值对“存入“Spring 容器的 Environment 环境里，以便在 Spring 应用中可以通过 @Value 或者占位符 ${key} 的形式来使用这些配置。 使用案列123456789101112131415161718// @PropertySource 需要和 @Configuration 配合使用// @PropertySource 加载配置文件时需要注意加载的顺序，后面加载的配置会覆盖前面加载的配置// @PropertySource 支持重复注解// value 值不仅支持 classpath 表达式，还支持任意合法的 URI 表达式@Configuration@PropertySource(value = &quot;classpath:/my.properties&quot;,encoding = &quot;UTF8&quot;)@PropertySource(value = &quot;classpath:/my2.properties&quot;,encoding = &quot;UTF8&quot;,ignoreResourceNotFound = true)public static class PropertyConfig {}@Componentpublic class App { @Value(&quot;${key1:default-val}&quot;) private String value; @Value(&quot;${key2:default-val2}&quot;) private String value2;} 下面是配置文件 my.properties 和 my2.properties 的具体内容。 123456# my.propertieskey1= 自由之路# my2.propertieskey1= 程序员key2= 自由之路 Spring 容器启动时，会将 my.properties 和 my2.properties 的内容加载到 Environment 中，并在 App 类的依赖注入环节，将 key1 和 key2 的值注入到对应的属性。 自定义 PropertySource 工厂阅读 @PropertySource 的源代码，我们发现还有一个 factory 属性。从这个属性的字面意思看，我们不难猜测出这个属性设置的是用于产生 PropertySource 的工厂。 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource { String name() default &quot;&quot;; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default &quot;&quot;; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;} 要深入理解 PropertySourceFactory，我们先要知道以下的背景知识。 在 Spring 中，配置的来源有很多。Spring 将配置来源统一抽象成 PropertySource 这个抽象类，Spring 中内建的常用的 PropertySource 有以下这些： MapPropertySource CommandLinePropertySource PropertiesPropertySource SystemEnvironmentPropertySource ResourcePropertySource ResourcePropertySource 这个类将一系列配置来源统一成 ResourcePropertySource，可以说是对 PropertySource 的进一步封装。 PropertySourceFactory 接口，用于产生 PropertySource。Spring 中，PropertySourceFactory 默认的实现是 DefaultPropertySourceFactory，用于生产 ResourcePropertySource。 经过上面的介绍，我们知道如果没有配置 @PropertySource 的 factory 属性的话，默认的 PropertySourceFactory 使用的就是 DefaultPropertySourceFactory。当然，我们也可以自定义 PropertySourceFactory，用于“生产”我们自定义的 PropertySource。下面就演示一个将 yaml 文件解析成 MapPropertySource 的使用案列。 12345678910111213141516171819202122/** * Spring 中内置的解析 yaml 的处理器 * YamlProcessor * - YamlMapFactoryBean --&gt; 解析成 Map * - YamlPropertiesFactoryBean --&gt; 解析成 Properties */public class YamlMapSourceFactory implements PropertySourceFactory { @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { YamlMapFactoryBean yamlMapFactoryBean = new YamlMapFactoryBean(); yamlMapFactoryBean.setResources(resource.getResource()); Map&lt;String, Object&gt; map = yamlMapFactoryBean.getObject(); return new MapPropertySource(name, map); }}// 加了 factory 属性，必须加 name 属性// 有了 factory 机制，我们可以做很多自定一的扩展，比如配置可以从远程来@Configuration@PropertySource(name = &quot;my.yaml&quot;,value = &quot;classpath:/my.yaml&quot;,encoding = &quot;UTF8&quot;,factory = YamlMapSourceFactory.class)public static class PropertyConfig {} 原理简析到这边我们对 @PropertySource 已经有了一个感性的认识，知道了其主要作用是将各种类型的外部化配置文件以键值对的形式加载到 Spring 的 Environment 中。这个部分我们从源码的角度来分析下 Spring 是怎么处理 @PropertySource 这个注解的。分析源码可以加深我们对 @PropertySource 的认识（看源码不是目的，是为了加深理解，学习 Spring 的设计思想）。 @PropertySource 注解的处理是在 ConfigurationClassPostProcessor 中进行触发的。最终会调用到 ConfigurationClassParser 的 processPropertySource 方法。 12345678910111213141516171819202122232425262728293031323334353637383940// ConfigurationClassParser#processPropertySourceprivate void processPropertySource(AnnotationAttributes propertySource) throws IOException { String name = propertySource.getString(&quot;name&quot;); if (!StringUtils.hasLength(name)) { name = null; } String encoding = propertySource.getString(&quot;encoding&quot;); if (!StringUtils.hasLength(encoding)) { encoding = null; } String[] locations = propertySource.getStringArray(&quot;value&quot;); Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;); boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;); // 如果有自定义工厂就使用自定义工厂，没有自定义工厂就使用 DefaultPropertySourceFactory PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); // 遍历各个 location 地址 for (String location : locations) { try { // location 地址支持占位符的形式 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); // 获取 Resource Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); } catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) { // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) { if (logger.isInfoEnabled()) { logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage()); } } else { throw ex; } } }} 总的来说，Spring 处理 @PropertySource 的源代码非常简单，这边就不再过多赘述了。","link":"/7276ee78dc1d/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[],"pages":[]}